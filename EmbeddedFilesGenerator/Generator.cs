using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Tomlyn;

namespace EmbeddedFilesGenerator;

[Generator(LanguageNames.CSharp)]
public class EmbeddedFilesGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        IncrementalValueProvider<ImmutableArray<AdditionalText>> filesProvider = context.AdditionalTextsProvider.Collect();

        // Generate the source code
        context.RegisterSourceOutput(filesProvider,
            static (context, files) => {
                if (files.IsEmpty) {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "EFGEN001",
                            "Missing additional files",
                            "Could not find any additional file. Add them as AdditionalFiles in your project: <AdditionalFiles Include=\"PATH\" />",
                            nameof(EmbeddedFilesGenerator),
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        Location.None));
                    return;
                }

                byte[] infoFileBytes = GetFileContent(files, "info.toml", context);
                string infoFileContent = Encoding.Default.GetString(infoFileBytes);

                List<ExerciseInfo> exercises = Toml.ToModel<InfoFile>(infoFileContent, options: new TomlModelOptions {
                    IgnoreMissingProperties = true
                }).Exercises;

                ImmutableArray<string> exerciseFiles = exercises.Select(ex => Path.Combine("Exercises", ex.Directory, $"{ex.Name}.cs")).ToImmutableArray();
                ImmutableArray<string> solutionFiles = exercises.Select(ex => Path.Combine("Solutions", ex.Directory, $"{ex.Name}.cs")).ToImmutableArray();

                List<string> dirs = [];
                List<int> dirInds = [];

                foreach (ExerciseInfo? exercise in exercises) {
                    // Search from the end (last inserted) - same as Rust's .rev().position()
                    int existingIndex = -1;
                    for (int i = dirs.Count - 1; i >= 0; i--) {
                        if (dirs[i] != exercise.Directory)
                            continue;

                        existingIndex = i;
                        break;
                    }

                    if (existingIndex >= 0) {
                        dirInds.Add(existingIndex);
                    } else {
                        dirs.Add(exercise.Directory);
                        dirInds.Add(dirs.Count - 1);
                    }
                }

                ImmutableArray<string> readmes = dirs.Select(dir => Path.Combine("Exercises", dir, "README.md")).ToImmutableArray();

                try {
                    string source = GenerateSource(infoFileBytes, exerciseFiles, solutionFiles, dirInds, dirs, readmes, files, context);
                    context.AddSource("EmbeddedFiles.g.cs", SourceText.From(source, Encoding.UTF8));
                } catch (Exception ex) {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "EFGEN002",
                            "Generation Error",
                            $"Failed to generate source: {ex.Message}\n{ex.StackTrace}",
                            nameof(EmbeddedFilesGenerator),
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        Location.None));
                }
            });
    }

    static string GenerateSource(
        byte[] infoFileBytes,
        IList<string> exerciseFiles,
        IList<string> solutionFiles,
        IList<int> dirIndexes,
        IList<string> dirs,
        IList<string> readmes,
        ImmutableArray<AdditionalText> files,
        SourceProductionContext context) {
        StringBuilder sb = new();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine();

        GenerateDataStructures(sb);
        GenerateEmbeddedFilesClass(sb, infoFileBytes, exerciseFiles, solutionFiles, dirIndexes, dirs, readmes, files, context);

        return sb.ToString();
    }

    static void GenerateDataStructures(StringBuilder sb) {
        sb.AppendLine("public readonly struct ExerciseFiles");
        sb.AppendLine("{");
        sb.AppendLine("    public byte[] Exercise { get; }");
        sb.AppendLine("    public byte[] Solution { get; }");
        sb.AppendLine("    public int DirInd { get; }");
        sb.AppendLine();
        sb.AppendLine("    internal ExerciseFiles(byte[] exercise, byte[] solution, int dirInd)");
        sb.AppendLine("    {");
        sb.AppendLine("        Exercise = exercise;");
        sb.AppendLine("        Solution = solution;");
        sb.AppendLine("        DirInd = dirInd;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("public readonly struct ExerciseDir");
        sb.AppendLine("{");
        sb.AppendLine("    public string Name { get; }");
        sb.AppendLine("    public byte[] Readme { get; }");
        sb.AppendLine();
        sb.AppendLine("    internal ExerciseDir(string name, byte[] readme)");
        sb.AppendLine("    {");
        sb.AppendLine("        Name = name;");
        sb.AppendLine("        Readme = readme;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("public sealed class EmbeddedFiles");
        sb.AppendLine("{");
        sb.AppendLine("    public Dictionary<string, byte[]> Files { get; }");
        sb.AppendLine("    public IList<ExerciseFiles> ExerciseFiles { get; }");
        sb.AppendLine("    public IList<ExerciseDir> ExerciseDirs { get; }");
        sb.AppendLine();
        sb.AppendLine("    internal EmbeddedFiles(Dictionary<string, byte[]> files, IList<ExerciseFiles> exerciseFiles, IList<ExerciseDir> exerciseDirs)");
        sb.AppendLine("    {");
        sb.AppendLine("        Files = files;");
        sb.AppendLine("        ExerciseFiles = exerciseFiles;");
        sb.AppendLine("        ExerciseDirs = exerciseDirs;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    static void GenerateEmbeddedFilesClass(
        StringBuilder sb,
        byte[] infoFileBytes,
        IList<string> exerciseFiles,
        IList<string> solutionFiles,
        IList<int> dirIndexes,
        IList<string> dirs,
        IList<string> readmes,
        ImmutableArray<AdditionalText> files,
        SourceProductionContext context) {
        sb.AppendLine("public static class EmbeddedFilesFactory");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly Lazy<EmbeddedFiles> _instance = new Lazy<EmbeddedFiles>(CreateInstance, System.Threading.LazyThreadSafetyMode.ExecutionAndPublication);");
        sb.AppendLine();
        sb.AppendLine("    public static EmbeddedFiles Instance => _instance.Value;");
        sb.AppendLine();
        sb.AppendLine("    private static EmbeddedFiles CreateInstance()");
        sb.AppendLine("    {");
        sb.AppendLine();
        sb.AppendLine("        IList<ExerciseFiles> exerciseFiles =");
        sb.AppendLine("        [");

        for (int i = 0; i < exerciseFiles.Count; i++) {
            string exercisePath = exerciseFiles[i];
            string solutionPath = solutionFiles[i];
            int dirIndex = dirIndexes[i];

            byte[] exerciseBytes = GetFileContent(files, exercisePath, context);
            byte[] solutionBytes = GetFileContent(files, solutionPath, context);

            sb.AppendLine("            new ExerciseFiles(");
            sb.AppendLine($"                exercise: {BytesTemplate(exerciseBytes)},");
            sb.AppendLine($"                solution: {BytesTemplate(solutionBytes)},");
            sb.AppendLine($"                dirInd: {dirIndex}");
            sb.AppendLine("            ),");
        }

        sb.AppendLine("        ];");
        sb.AppendLine();

        sb.AppendLine("        IList<ExerciseDir> exerciseDirs =");
        sb.AppendLine("        [");

        for (int i = 0; i < dirs.Count; i++) {
            string? dir = dirs[i];
            string readmePath = readmes[i];
            byte[] readmeBytes = GetFileContent(files, readmePath, context);

            sb.AppendLine("            new ExerciseDir(");
            sb.AppendLine($"                name: \"{dir}\",");
            sb.AppendLine($"                readme: {BytesTemplate(readmeBytes)}");
            sb.AppendLine("            ),");
        }

        sb.AppendLine("        ];");
        sb.AppendLine();

        byte[] exercisesReadmeBytes = GetFileContent(files, Path.Combine("Exercises", "README.md"), context);
        byte[] solutionsReadmeBytes = GetFileContent(files, Path.Combine("Solutions", "README.md"), context);
        byte[] editorConfigBytes = GetFileContent(files, ".editorconfig", context);
        byte[] sharplingsSlnBytes = GetFileContent(files, "Sharplings.sln", context);
        byte[] exercisesCsprojBytes = GetFileContent(files, Path.Combine("Exercises", "Exercises.csproj"), context);
        byte[] solutionsCsprojBytes = GetFileContent(files, Path.Combine("Solutions", "Solutions.csproj"), context);

        sb.AppendLine("        Dictionary<string, byte[]> files = new()");
        sb.AppendLine("        {");

        sb.AppendLine($"            {DictionaryEntryTemplate("InfoFile", infoFileBytes)},");
        sb.AppendLine($"            {DictionaryEntryTemplate("ExercisesReadme", exercisesReadmeBytes)},");
        sb.AppendLine($"            {DictionaryEntryTemplate("SolutionsReadme", solutionsReadmeBytes)},");
        sb.AppendLine($"            {DictionaryEntryTemplate("EditorConfig", editorConfigBytes)},");
        sb.AppendLine($"            {DictionaryEntryTemplate("ExercisesCsproj", exercisesCsprojBytes)},");
        sb.AppendLine($"            {DictionaryEntryTemplate("SolutionsCsproj", solutionsCsprojBytes)},");
        sb.AppendLine($"            {DictionaryEntryTemplate("SharplingsSln", sharplingsSlnBytes)},");

        sb.AppendLine("        };");
        sb.AppendLine();

        sb.AppendLine($"        return new EmbeddedFiles(files, exerciseFiles, exerciseDirs);");
        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    static byte[] GetFileContent(ImmutableArray<AdditionalText> files, string path, SourceProductionContext context) {
        SourceText? content = files.SingleOrDefault(file => file.Path.EndsWith(path))?.GetText();
        if (content != null) return GetContentAsByteArray(content);

        context.ReportDiagnostic(Diagnostic.Create(
            new DiagnosticDescriptor(
                "EFGEN003",
                $"Missing {path}",
                $"Could not find file {path}. Add it as AdditionalFiles in your project: <AdditionalFiles Include=\"{path}\" />",
                nameof(EmbeddedFilesGenerator),
                DiagnosticSeverity.Error,
                isEnabledByDefault: true),
            Location.None));

        throw new InvalidOperationException($"Missing {path}");
    }

    static byte[] GetContentAsByteArray(SourceText content) {
        using MemoryStream stream = new();
        using (StreamWriter writer = new(stream))
            content.Write(writer);

        return stream.ToArray();
    }

    static string DictionaryEntryTemplate(string key, byte[] value) => $"{{ \"{key}\", {BytesTemplate(value)} }}";

    static string BytesTemplate(byte[] bytes) => $"[{string.Join(",", bytes)}]";

    // ReSharper disable AutoPropertyCanBeMadeGetOnly.Local
    class InfoFile {
        public List<ExerciseInfo> Exercises { get; set; } = null!;
    }

    // ReSharper disable once ClassNeverInstantiated.Local
    class ExerciseInfo {
        public string Name { get; set; } = null!;

        public string Directory { get; set; } = null!;
    }
    // ReSharper restore AutoPropertyCanBeMadeGetOnly.Local
}
